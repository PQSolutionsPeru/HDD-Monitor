--- Contenido de main.py ---

import urequests
import utime
import json
from wifi_manager import WiFiManager
from mqtt_manager import MQTTManager
from relay_manager import RelayManager
from watchdog_manager import WatchdogManager
import gc

# Configuración
RELAY_PINS = [32, 33, 25]
RELAY_NAMES = {32: "Alarma", 33: "Problema", 25: "Supervision"}

# Managers
wifi_manager = WiFiManager()
mqtt_manager = MQTTManager(wifi_manager)
relay_manager = RelayManager()
watchdog_manager = WatchdogManager()

cached_datetime = None
last_datetime_update = utime.ticks_ms()
memory_report_enabled = True  # Cambiar a False para desactivar los informes de memoria

def get_current_datetime():
    global cached_datetime, last_datetime_update
    current_ticks = utime.ticks_ms()
    if utime.ticks_diff(current_ticks, last_datetime_update) > 600000 or cached_datetime is None:  # 10 minutos
        update_datetime()
    return cached_datetime

def update_datetime():
    global cached_datetime, last_datetime_update
    try:
        cached_datetime = wifi_manager.get_current_time()
        print(f"Fecha y hora actuales actualizadas a: {cached_datetime}")
    except Exception as e:
        print(f"Error al obtener fecha y hora, usando última conocida o 'unknown': {e}")
        cached_datetime = cached_datetime if cached_datetime else "unknown"
    last_datetime_update = utime.ticks_ms()


def relay_callback(pin, pin_num):
    gc.collect()  # Recolectar basura antes de procesar
    print(f"Callback de relay activado para el pin {pin_num}.")
    wifi_manager.ensure_wifi_connected()  # Verificar conexión WiFi antes de proceder
    current_datetime = get_current_datetime()  # Asegurarse de usar la fecha y hora formateada
    status = "DISC" if pin.value() else "OK"
    message = {
        "date_time": current_datetime,  # Usar la fecha y hora formateada
        "name": RELAY_NAMES.get(pin_num, "Relay Desconocido"),
        "status": status
    }
    print(f"Enviando mensaje MQTT: {message}")
    mqtt_manager.publish_event(f"EMPRESA_TEST/{mqtt_manager.MQTT_CLIENT_ID}/eventos", json.dumps(message))



def main():
    last_memory_report_time = utime.ticks_ms()
    while not wifi_manager.sta_if.isconnected():
        wifi_manager.connect_wifi()
    mqtt_manager.ensure_client()
    for relay_pin in RELAY_PINS:
        pin = relay_manager.setup_relay(relay_pin, relay_callback)
    while True:
        utime.sleep(1)
        watchdog_manager.feed()
        current_time = utime.ticks_ms()
        if memory_report_enabled and utime.ticks_diff(current_time, last_memory_report_time) > 60000:  # 1 minuto
            free_memory = gc.mem_free()
            print(f"Reporte de memoria libre: {free_memory} bytes")
            last_memory_report_time = current_time
            gc.collect()  # Recolección de basura para mantener la memoria limpia

if __name__ == "__main__":
    main()



--- Contenido de mqtt_manager.py ---

from umqtt.robust import MQTTClient
import time

class MQTTManager:
    def __init__(self, wifi_manager):
        self.wifi_manager = wifi_manager  # Guardar referencia al WiFiManager
        self.client = None
        self.message_queue = []  # Cola para mensajes pendientes
        self.MQTT_BROKER = "node02.myqtthub.com"
        self.MQTT_PORT = 8883
        self.MQTT_CLIENT_ID = "ESP32-PQ1"
        self.MQTT_USER = "ESP32-1"
        self.MQTT_PASSWORD = "esp32"

    def ensure_client(self):
        self.wifi_manager.ensure_wifi_connected()  # Asegurar conexión WiFi
        try:
            if self.client is None or not self.client.isconnected():
                print("Reinicializando cliente MQTT...")
                self.reinitialize_client()
        except AttributeError:  # Por si 'isconnected' no está disponible
            self.reinitialize_client()

    def reinitialize_client(self):
        try:
            self.client = MQTTClient(self.MQTT_CLIENT_ID.encode('utf-8'), self.MQTT_BROKER, self.MQTT_PORT,
                                     user=self.MQTT_USER.encode('utf-8'), password=self.MQTT_PASSWORD.encode('utf-8'), ssl=True)
            self.client.connect()
            print("Conectado al broker MQTT después de la reconexión.")
        except Exception as e:
            print(f"No se pudo conectar al broker MQTT: {e}")
            self.client = None

    def publish_event(self, topic, message):
        self.ensure_client()  # Asegurarse de que el cliente MQTT está conectado
        try:
            if self.client:
                print("Enviando mensaje...")
                self.client.publish(topic, message, qos=1)
                print(f"Evento enviado al broker MQTT: {message}")
        except Exception as e:
            print(f"Fallo al publicar debido a: {e}")
            self.message_queue.append({'topic': topic, 'message': message})  # Encolar mensaje si la publicación falla
            self.client = None



--- Contenido de performance_monitor.py ---

import gc
import utime

def check_performance(func, *args, **kwargs):
    gc.collect()  # Collect garbage and measure free memory before execution
    free_memory_before = gc.mem_free()
    print("Memoria libre antes de la ejecución:", free_memory_before)

    start_time = utime.ticks_ms()  # Start time in milliseconds
    func(*args, **kwargs)  # Execute the function with provided arguments
    end_time = utime.ticks_ms()  # End time in milliseconds
    execution_time = utime.ticks_diff(end_time, start_time)  # Calculate the time difference

    gc.collect()  # Collect garbage and measure free memory after execution
    free_memory_after = gc.mem_free()
    print(f"Tiempo de ejecución de {func.__name__}: {execution_time} ms")
    print("Memoria libre después de la ejecución:", free_memory_after)

    memory_change = free_memory_before - free_memory_after
    print(f"Cambio en la memoria usada: {memory_change} bytes")



--- Contenido de relay_manager.py ---

from machine import Pin
import time

class RelayManager:
    def __init__(self):
        self.relays = {}
        self.relay_states = {}
        self.last_trigger_time = {}

    def setup_relay(self, pin_num, callback):
        pin = Pin(pin_num, Pin.IN, Pin.PULL_UP)
        self.relays[pin_num] = pin
        self.relay_states[pin_num] = pin.value()
        pin.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=lambda p: self.debounce(pin_num, p, callback))
        return pin

    def debounce(self, pin_num, pin, callback):
        current_time = time.ticks_ms()
        if current_time - self.last_trigger_time.get(pin_num, 0) > 300 and self.relay_states[pin_num] != pin.value():  # 300 ms debounce period
            self.relay_states[pin_num] = pin.value()  # Actualizar el estado del relay
            callback(pin, pin_num)
            self.last_trigger_time[pin_num] = current_time



--- Contenido de watchdog_manager.py ---

from machine import WDT

class WatchdogManager:
    def __init__(self, timeout=120000):
        # Configura el watchdog con un timeout de 120 segundos por defecto
        self.watchdog = WDT(timeout=timeout)
    
    def feed(self):
        # Alimenta al watchdog para resetear el timer y evitar un reset del sistema
        self.watchdog.feed()



--- Contenido de wifi_manager.py ---

import machine
import utime
import network
import urequests

class WiFiManager:
    SSID = "PABLO-2.4G"
    PASSWORD = "47009410"

    def __init__(self):
        self.sta_if = network.WLAN(network.STA_IF)
        self.sta_if.active(True)

    def connect_wifi(self):
        while not self.sta_if.isconnected():
            print("Conectando a WiFi...")
            self.sta_if.connect(self.SSID, self.PASSWORD)
            start_time = utime.ticks_ms()
            while not self.sta_if.isconnected() and utime.ticks_diff(utime.ticks_ms(), start_time) < 10000:
                utime.sleep(1)
            if self.sta_if.isconnected():
                print("Conectado a WiFi.")
            else:
                print("Reintentando conectar a WiFi...")
                utime.sleep(5)  # Espera antes de reintentar

    def ensure_wifi_connected(self):
        if not self.sta_if.isconnected():
            print("WiFi desconectado, intentando reconectar...")
            self.connect_wifi()

    def check_connection(self):
        self.ensure_wifi_connected()

    def get_current_time(self):
        self.check_connection()
        current_time = self._get_world_time()
        return current_time

    def _get_world_time(self):
        try:
            response = urequests.get("http://worldtimeapi.org/api/timezone/America/Lima")
            data = response.json()
            current_datetime = data["datetime"]
            response.close()
            return self._format_datetime(current_datetime)
        except Exception as e:
            print("Error al obtener la fecha y hora:", e)
            return None

    def _format_datetime(self, datetime_str):
        # Formatear la fecha y hora según los requisitos
        year, month, day = datetime_str[:10].split("-")
        time_str = datetime_str[11:19]
        return f"el {day}-{month}-{year} a las {time_str}"


