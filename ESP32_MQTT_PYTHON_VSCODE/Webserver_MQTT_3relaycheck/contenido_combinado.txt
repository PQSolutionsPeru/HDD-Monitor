--- Contenido de main.py ---

import urequests
import utime
import json
import _thread
from wifi_manager import WiFiManager
from mqtt_manager import MQTTManager
from relay_manager import RelayManager
from watchdog_manager import WatchdogManager
from machine import Timer
import gc

# Configuration
RELAY_PINS = [32, 33, 25]
RELAY_NAMES = {32: "Alarma", 33: "Problema", 25: "Supervision"}

# Managers
wifi_manager = WiFiManager()
mqtt_manager = MQTTManager()
relay_manager = RelayManager()
watchdog_manager = WatchdogManager()

# Memory Management
memory_timer = Timer(-1)

def memory_watchdog(timer):
    gc.collect()
    free_memory = gc.mem_free()
    print(f"Memoria libre actual: {free_memory} bytes")
    if free_memory < 50000:
        print("Posible fuga de memoria detectada.")

memory_timer.init(period=60000, mode=Timer.PERIODIC, callback=memory_watchdog)

def network_thread():
    while True:
        wifi_manager.check_connection()
        utime.sleep(5)

def get_current_datetime():
    try:
        response = urequests.get("http://worldtimeapi.org/api/timezone/America/Lima")
        data = response.json()
        current_datetime = data["datetime"]
        response.close()
        print(f"Current datetime fetched successfully: {current_datetime}")
        return current_datetime
    except Exception as e:
        print(f"Error al obtener la fecha y hora: {e}")
        return None

def relay_callback(pin, pin_num):
    current_datetime = get_current_datetime()
    if current_datetime:
        message = {
            "date_time": current_datetime[:19],
            "name": RELAY_NAMES.get(pin_num, "Unknown Relay"),
            "status": "DISC" if pin.value() else "OK"
        }
        print(f"Preparing to send MQTT message: {message}")
        mqtt_manager.publish_event(f"EMPRESA_TEST/{mqtt_manager.MQTT_CLIENT_ID}/eventos", json.dumps(message))

def main():
    _thread.start_new_thread(network_thread, ())
    wifi_manager.connect_wifi()
    mqtt_manager.ensure_client()
    for relay_pin in RELAY_PINS:
        pin = relay_manager.setup_relay(relay_pin, relay_callback)
    last_feed_time = utime.ticks_ms()
    while True:
        current_time = utime.ticks_ms()
        if utime.ticks_diff(current_time, last_feed_time) > 5000:
            watchdog_manager.feed()
            print("Watchdog fed.")
            last_feed_time = current_time
        utime.sleep(1)

if __name__ == "__main__":
    main()



--- Contenido de mqtt_manager.py ---

from umqtt.robust import MQTTClient
import time

class MQTTManager:
    MQTT_BROKER = "node02.myqtthub.com"
    MQTT_PORT = 8883
    MQTT_CLIENT_ID = "ESP32-PQ1"
    MQTT_USER = "ESP32-1"
    MQTT_PASSWORD = "esp32"
    MAX_RETRIES = 3
    RETRY_DELAY = 10  # 10 seconds delay before retry

    def __init__(self):
        self.client = None

    def ensure_client(self, retry_count=0):
        if self.client is None and retry_count < self.MAX_RETRIES:
            self.client = MQTTClient(self.MQTT_CLIENT_ID.encode('utf-8'), self.MQTT_BROKER, self.MQTT_PORT,
                                     user=self.MQTT_USER.encode('utf-8'), password=self.MQTT_PASSWORD.encode('utf-8'), ssl=True)
            try:
                self.client.connect()
                print("Connected to MQTT Broker!")
            except Exception as e:
                print(f"Failed to connect to MQTT: {str(e)}")
                self.client = None
                time.sleep(self.RETRY_DELAY)
                if retry_count + 1 < self.MAX_RETRIES:
                    self.ensure_client(retry_count + 1)
        elif retry_count >= self.MAX_RETRIES:
            print("Failed to connect after several retries. Check network and broker settings.")

    def publish_event(self, topic, message):
        try:
            if self.client is None:
                print("Client not connected. Attempting to reconnect...")
                self.ensure_client()
            self.client.publish(topic, message, qos=1)
            print(f"Evento enviado al broker MQTT: {message}")
        except Exception as e:
            print(f"Failed to publish: {str(e)}")
            self.client = None
            self.ensure_client()  # Reconnect on failure



--- Contenido de performance_monitor.py ---

import gc
import utime

def check_performance(func, *args, **kwargs):
    gc.collect()  # Collect garbage and measure free memory before execution
    free_memory_before = gc.mem_free()
    print("Memoria libre antes de la ejecución:", free_memory_before)

    start_time = utime.ticks_ms()  # Start time in milliseconds
    func(*args, **kwargs)  # Execute the function with provided arguments
    end_time = utime.ticks_ms()  # End time in milliseconds
    execution_time = utime.ticks_diff(end_time, start_time)  # Calculate the time difference

    gc.collect()  # Collect garbage and measure free memory after execution
    free_memory_after = gc.mem_free()
    print(f"Tiempo de ejecución de {func.__name__}: {execution_time} ms")
    print("Memoria libre después de la ejecución:", free_memory_after)

    memory_change = free_memory_before - free_memory_after
    print(f"Cambio en la memoria usada: {memory_change} bytes")



--- Contenido de relay_manager.py ---

from machine import Pin
import time

class RelayManager:
    def __init__(self):
        self.relays = {}
        self.relay_states = {}
        self.last_trigger_time = {}

    def setup_relay(self, pin_num, callback):
        pin = Pin(pin_num, Pin.IN, Pin.PULL_UP)
        self.relays[pin_num] = pin
        self.relay_states[pin_num] = pin.value()
        pin.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=lambda p: self.debounce(pin_num, p, callback))
        return pin

    def debounce(self, pin_num, pin, callback):
        current_time = time.ticks_ms()
        if current_time - self.last_trigger_time.get(pin_num, 0) > 300 and self.relay_states[pin_num] != pin.value():  # 300 ms debounce period
            self.relay_states[pin_num] = pin.value()  # Actualizar el estado del relay
            callback(pin, pin_num)
            self.last_trigger_time[pin_num] = current_time



--- Contenido de watchdog_manager.py ---

from machine import WDT

class WatchdogManager:
    def __init__(self, timeout=120000):
        # Configura el watchdog con un timeout de 120 segundos por defecto
        self.watchdog = WDT(timeout=timeout)
    
    def feed(self):
        # Alimenta al watchdog para resetear el timer y evitar un reset del sistema
        self.watchdog.feed()



--- Contenido de wifi_manager.py ---

import machine
import utime
import network
import urequests
import _thread

class WiFiManager:
    SSID = "PABLO-2.4G"
    PASSWORD = "47009410"

    def __init__(self):
        self.sta_if = network.WLAN(network.STA_IF)
        self.wifi_connected = False
        self.lock = _thread.allocate_lock()  # Mutex para controlar el acceso a la conexión

    def connect_wifi(self):
        with self.lock:  # Asegurar acceso exclusivo al proceso de conexión
            if not self.sta_if.isconnected():
                print("Conectando a WiFi...")
                self.sta_if.active(True)
                self.sta_if.connect(self.SSID, self.PASSWORD)
                start_time = utime.ticks_ms()
                while not self.sta_if.isconnected():
                    if utime.ticks_diff(utime.ticks_ms(), start_time) > 10000:  # Timeout después de 10 segundos
                        print("Timeout al intentar conectar a WiFi")
                        return
                    utime.sleep(1)
                print("Conectado a WiFi")
                self.wifi_connected = True
            else:
                print("Already connected to WiFi")

    def check_connection(self):
        if not self.sta_if.isconnected():
            print("Reconectando a WiFi...")
            self.connect_wifi()

    def get_current_time(self):
        self.check_connection()
        current_time = self._get_world_time()
        return current_time

    def _get_world_time(self):
        try:
            response = urequests.get("http://worldtimeapi.org/api/timezone/America/Lima")
            data = response.json()
            current_datetime = data["datetime"]
            response.close()
            return self._format_datetime(current_datetime)
        except Exception as e:
            print("Error al obtener la fecha y hora:", e)
            return None

    def _format_datetime(self, datetime_str):
        # Formatear la fecha y hora según los requisitos
        year, month, day = datetime_str[:10].split("-")
        time_str = datetime_str[11:19]
        return f"el {day}-{month}-{year} a las {time_str}"


