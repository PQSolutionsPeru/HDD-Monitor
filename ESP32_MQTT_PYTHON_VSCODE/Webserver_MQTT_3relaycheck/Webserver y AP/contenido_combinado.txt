--- Contenido de boot.py ---

import webserver
import machine

# Iniciar el servidor web al inicio
webserver.iniciar()



--- Contenido de log_manager.py ---

import os
import utime

LOG_DIR = '/logs'
LOG_FILE = LOG_DIR + '/log.txt'
LOG_MAX_SIZE = 256 * 1024  # 256 KB
LOG_MAX_FILES = 4

class LogManager:
    def __init__(self):
        self.ensure_log_dir()

    def ensure_log_dir(self):
        try:
            os.mkdir(LOG_DIR)
        except OSError as e:
            if e.args[0] != 17:  # 17 significa que el directorio ya existe
                raise

    def log(self, message):
        timestamp = self.get_timestamp()
        log_message = f"{timestamp} - {message}\n"
        with open(LOG_FILE, 'a') as f:
            f.write(log_message)
        self.check_log_size()

    def get_timestamp(self):
        tm = utime.localtime()
        return "{:04d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}".format(tm[0], tm[1], tm[2], tm[3], tm[4], tm[5])

    def check_log_size(self):
        if os.stat(LOG_FILE)[6] > LOG_MAX_SIZE:
            self.rotate_logs()

    def rotate_logs(self):
        for i in range(LOG_MAX_FILES - 1, 0, -1):
            old_file = f"{LOG_FILE}.{i}"
            new_file = f"{LOG_FILE}.{i + 1}"
            if os.path.exists(old_file):
                os.rename(old_file, new_file)
        os.rename(LOG_FILE, f"{LOG_FILE}.1")

    def delete_old_logs(self):
        for i in range(LOG_MAX_FILES + 1, 100):
            old_file = f"{LOG_FILE}.{i}"
            try:
                os.remove(old_file)
            except OSError:
                pass

log_manager = LogManager()

def log_message(message):
    log_manager.log(message)

def delete_old_logs():
    log_manager.delete_old_logs()



--- Contenido de main.py ---

import urequests
import utime
import json
from wifi_manager import WiFiManager
from mqtt_manager import MQTTManager
from relay_manager import RelayManager
from watchdog_manager import WatchdogManager
import gc
import log_manager
import webserver
from log_manager import delete_old_logs

# Configuración
RELAY_PINS = [32, 33, 25]
RELAY_NAMES = {32: "Alarma", 33: "Problema", 25: "Supervision"}

# Managers
wifi_manager = WiFiManager()
mqtt_manager = MQTTManager(wifi_manager)
relay_manager = RelayManager()
watchdog_manager = WatchdogManager()

cached_datetime = None
last_datetime_update = utime.ticks_ms()
memory_report_enabled = True  # Cambiar a False para desactivar los informes de memoria

# Redirigir print a consola WebSocket y log
def print_console(*args, **kwargs):
    message = ' '.join(map(str, args))
    webserver.send_console_output(message)
    log_manager.log_message(message)

# Usar la función personalizada en lugar de print
print = print_console

def obtener_fecha_hora_actual():
    global cached_datetime, last_datetime_update
    current_ticks = utime.ticks_ms()
    if utime.ticks_diff(current_ticks, last_datetime_update) > 600000 or cached_datetime is None:  # 10 minutos
        actualizar_fecha_hora()
    return cached_datetime

def actualizar_fecha_hora():
    global cached_datetime, last_datetime_update
    try:
        cached_datetime = wifi_manager.obtener_hora_actual()
        print(f"Fecha y hora actuales actualizadas a: {cached_datetime}")
    except Exception as e:
        print(f"Error al obtener fecha y hora, usando última conocida o 'unknown': {e}")
        cached_datetime = cached_datetime if cached_datetime else "unknown"
    last_datetime_update = utime.ticks_ms()

def relay_callback(pin, pin_num):
    try:
        gc.collect()  # Recolectar basura antes de procesar
        print(f"Callback de relay activado para el pin {pin_num}.")
        wifi_manager.asegurar_conexion_wifi()  # Verificar conexión WiFi antes de proceder
        current_datetime = obtener_fecha_hora_actual()  # Asegurarse de usar la fecha y hora formateada
        status = "DISC" if pin.value() else "OK"
        message = {
            "date_time": current_datetime,  # Usar la fecha y hora formateada
            "name": RELAY_NAMES.get(pin_num, "Relay Desconocido"),
            "status": status
        }
        print(f"Enviando mensaje MQTT: {message}")
        mqtt_manager.publicar_evento(f"EMPRESA_TEST/{mqtt_manager.MQTT_CLIENT_ID}/eventos", json.dumps(message))
    except Exception as e:
        print(f"Error en relay_callback: {e}")

def main():
    try:
        last_memory_report_time = utime.ticks_ms()
        while not wifi_manager.sta_if.isconnected():
            wifi_manager.conectar_wifi()
        mqtt_manager.asegurar_cliente()
        for relay_pin in RELAY_PINS:
            pin = relay_manager.configurar_relay(relay_pin, relay_callback)
        while True:
            utime.sleep(1)
            watchdog_manager.alimentar()
            current_time = utime.ticks_ms()
            if memory_report_enabled and utime.ticks_diff(current_time, last_memory_report_time) > 60000:  # 1 minuto
                free_memory = gc.mem_free()
                print(f"Reporte de memoria libre: {free_memory} bytes")
                last_memory_report_time = current_time
                gc.collect()  # Recolección de basura para mantener la memoria limpia
            delete_old_logs()
    except Exception as e:
        print(f"Error en main: {e}")

if __name__ == "__main__":
    main()



--- Contenido de mqtt_manager.py ---

from umqtt.robust import MQTTClient
import time

class MQTTManager:
    def __init__(self, wifi_manager):
        self.wifi_manager = wifi_manager  # Guardar referencia al WiFiManager
        self.client = None
        self.message_queue = []  # Cola para mensajes pendientes
        self.MQTT_BROKER = "node02.myqtthub.com"
        self.MQTT_PORT = 8883
        self.MQTT_CLIENT_ID = "ESP32-PQ1"
        self.MQTT_USER = "ESP32-1"
        self.MQTT_PASSWORD = "esp32"

    def asegurar_cliente(self):
        self.wifi_manager.asegurar_conexion_wifi()  # Asegurar conexión WiFi
        try:
            if self.client is None or not self.client.isconnected():
                print("Reinicializando cliente MQTT...")
                self.reinicializar_cliente()
        except AttributeError:  # Por si 'isconnected' no está disponible
            self.reinicializar_cliente()

    def reinicializar_cliente(self):
        try:
            self.client = MQTTClient(self.MQTT_CLIENT_ID.encode('utf-8'), self.MQTT_BROKER, self.MQTT_PORT,
                                     user=self.MQTT_USER.encode('utf-8'), password=self.MQTT_PASSWORD.encode('utf-8'), ssl=True)
            self.client.connect()
            print("Conectado al broker MQTT después de la reconexión.")
        except Exception as e:
            print(f"No se pudo conectar al broker MQTT: {e}")
            self.client = None

    def publicar_evento(self, topic, message):
        try:
            self.asegurar_cliente()  # Asegurarse de que el cliente MQTT está conectado
            if self.client:
                print("Enviando mensaje...")
                self.client.publish(topic, message, qos=1)
                print(f"Evento enviado al broker MQTT: {message}")
        except Exception as e:
            print(f"Fallo al publicar debido a: {e}")
            self.message_queue.append({'topic': topic, 'message': message})  # Encolar mensaje si la publicación falla
            self.client = None



--- Contenido de performance_monitor.py ---

import gc
import utime

def chequear_rendimiento(func, *args, **kwargs):
    gc.collect()  # Recolectar basura y medir memoria libre antes de la ejecución
    memoria_libre_antes = gc.mem_free()
    print("Memoria libre antes de la ejecución:", memoria_libre_antes)

    tiempo_inicio = utime.ticks_ms()  # Tiempo de inicio en milisegundos
    func(*args, **kwargs)  # Ejecutar la función con los argumentos proporcionados
    tiempo_fin = utime.ticks_ms()  # Tiempo de finalización en milisegundos
    tiempo_ejecucion = utime.ticks_diff(tiempo_fin, tiempo_inicio)  # Calcular la diferencia de tiempo

    gc.collect()  # Recolectar basura y medir memoria libre después de la ejecución
    memoria_libre_despues = gc.mem_free()
    print(f"Tiempo de ejecución de {func.__name__}: {tiempo_ejecucion} ms")
    print("Memoria libre después de la ejecución:", memoria_libre_despues)

    cambio_memoria = memoria_libre_antes - memoria_libre_despues
    print(f"Cambio en la memoria usada: {cambio_memoria} bytes")



--- Contenido de relay_manager.py ---

from machine import Pin
import time

class RelayManager:
    def __init__(self):
        self.relays = {}
        self.relay_states = {}
        self.last_trigger_time = {}

    def configurar_relay(self, pin_num, callback):
        pin = Pin(pin_num, Pin.IN, Pin.PULL_UP)
        self.relays[pin_num] = pin
        self.relay_states[pin_num] = pin.value()
        pin.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=lambda p: self.debounce(pin_num, p, callback))
        return pin

    def debounce(self, pin_num, pin, callback):
        try:
            current_time = time.ticks_ms()
            if current_time - self.last_trigger_time.get(pin_num, 0) > 300 and self.relay_states[pin_num] != pin.value():  # 300 ms de debounce
                self.relay_states[pin_num] = pin.value()  # Actualizar el estado del relay
                callback(pin, pin_num)
                self.last_trigger_time[pin_num] = current_time
        except Exception as e:
            print(f"Error en debounce: {e}")



--- Contenido de watchdog_manager.py ---

from machine import WDT

class WatchdogManager:
    def __init__(self, timeout=120000):
        # Configura el watchdog con un timeout de 120 segundos por defecto
        self.watchdog = WDT(timeout=timeout)
    
    def alimentar(self):
        # Alimenta al watchdog para resetear el timer y evitar un reset del sistema
        self.watchdog.feed()



--- Contenido de webserver.py ---

import usocket as socket
import machine
import ubinascii
import os
import esp32
import json
from wifi_manager import WiFiManager
import _thread
import log_manager
from websocket_helper import websocket_handler

wifi_manager = WiFiManager()
watchdog_manager = WatchdogManager()

# HTML para las diferentes secciones del servidor web
html_template = """
<!DOCTYPE html>
<html>
<head>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }}
        .sidenav {{
            height: 100%;
            width: 200px;
            position: fixed;
            z-index: 1;
            top: 0;
            left: 0;
            background-color: #111;
            padding-top: 20px;
        }}
        .sidenav a {{
            padding: 8px 8px 8px 16px;
            text-decoration: none;
            font-size: 18px;
            color: #818181;
            display: block;
        }}
        .sidenav a:hover {{
            color: #f1f1f1;
        }}
        .main {{
            margin-left: 200px;
            padding: 0px 10px;
        }}
    </style>
    <script>
        function setDarkMode() {{
            document.body.style.backgroundColor = '#000';
            document.body.style.color = '#fff';
        }}

        function setLightMode() {{
            document.body.style.backgroundColor = '#fff';
            document.body.style.color = '#000';
        }}

        function toggleDarkMode() {{
            if (document.body.style.backgroundColor === 'rgb(0, 0, 0)') {{
                setLightMode();
                localStorage.setItem('mode', 'light');
            }} else {{
                setDarkMode();
                localStorage.setItem('mode', 'dark');
            }}
        }}

        document.addEventListener('DOMContentLoaded', (event) => {{
            const mode = localStorage.getItem('mode');
            if (mode === 'dark') {{
                setDarkMode();
            }} else {{
                setLightMode();
            }}
        }});
    </script>
</head>
<body>
    <div class="sidenav">
        <a href="/">Inicio</a>
        <a href="/config">Configuración Wi-Fi</a>
        <a href="/reboot">Reiniciar</a>
        <a href="/manage">Gestión de Archivos</a>
        <a href="/logs">Logs</a>
        <a href="#" onclick="toggleDarkMode()">Modo Oscuro</a>
    </div>
    <div class="main">
        {content}
    </div>
</body>
</html>
"""

# Credenciales para autenticación básica
BASIC_AUTH_CREDENTIALS = "admin:1234556"  # Cambia esto por tus credenciales

# WebSocket clients list
ws_clients = []

# Servidor HTTP
def iniciar_servidor():
    addr = socket.getaddrinfo('0.0.0.0', 8080)[0][-1]
    s = socket.socket()
    s.bind(addr)
    s.listen(5)
    print('Escuchando en', addr)

    while True:
        cl, addr = s.accept()
        print('Cliente conectado desde', addr)
        try:
            request = cl.recv(1024).decode()
            if autenticar(request):
                if "Upgrade: websocket" in request:
                    _thread.start_new_thread(manejar_websocket, (cl,))
                else:
                    manejar_solicitud(cl, request)
            else:
                cl.send('HTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Basic realm="ESP32"\r\n\r\n')
        except Exception as e:
            print('Error al manejar la solicitud:', e)
        finally:
            cl.close()
        # Alimentar el watchdog después de cada solicitud
        watchdog_manager.alimentar()

# Verificar autenticación básica
def autenticar(request):
    headers = request.split("\r\n")
    for header in headers:
        if header.startswith("Authorization: Basic "):
            encoded_credentials = header.split(" ")[2]
            decoded_credentials = ubinascii.a2b_base64(encoded_credentials).decode("utf-8")
            if decoded_credentials == BASIC_AUTH_CREDENTIALS:
                return True
    return False

# Manejar solicitudes HTTP
def manejar_solicitud(cliente, solicitud):
    request_line = solicitud.split('\n')[0]
    method, path, _ = request_line.split()

    if method == 'GET' and path == '/':
        response = servir_pagina_principal()
    elif method == 'GET' and path == '/config':
        response = servir_pagina_config()
    elif method == 'POST' and path == '/config':
        response = manejar_post_config(solicitud)
    elif method == 'GET' and path == '/reboot':
        response = servir_pagina_reboot()
    elif method == 'POST' and path == '/reboot':
        response = manejar_post_reboot()
    elif method == 'GET' and path == '/manage':
        response = servir_pagina_gestion_archivos()
    elif method == 'POST' and path == '/upload':
        response = manejar_post_upload(solicitud)
    elif method == 'POST' and path == '/start':
        response = manejar_post_start(solicitud)
    elif method == 'POST' and path == '/stop':
        response = manejar_post_stop()
    elif method == 'DELETE' and path.startswith('/file/'):
        response = manejar_delete_file(solicitud, path)
    elif method == 'GET' and path == '/logs':
        response = servir_pagina_logs()
    else:
        response = 'HTTP/1.1 404 Not Found\r\n\r\n'

    cliente.send(response)

# Servir página de inicio
def servir_pagina_principal():
    content = "<h2>Bienvenido al Monitor de HDD</h2><p>Seleccione una opción del menú.</p>"
    return 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n' + html_template.format(content=content)

# Servir página de configuración Wi-Fi
def servir_pagina_config():
    content = """
    <h2>Configuración Wi-Fi</h2>
    <form action="/config" method="post">
        <label for="ssid">SSID:</label>
        <input type="text" id="ssid" name="ssid"><br>
        <label for="password">Password:</label>
        <input type="password" id="password" name="password"><br>
        <label for="use_static_ip">Usar IP estática:</label>
        <input type="checkbox" id="use_static_ip" name="use_static_ip" onchange="toggleStaticIP()"><br>
        <div id="static_ip_config" style="display: none;">
            <label for="ip">IP:</label>
            <input type="text" id="ip" name="ip"><br>
            <label for="netmask">Netmask:</label>
            <input type="text" id="netmask" name="netmask"><br>
            <label for="gateway">Gateway:</label>
            <input type="text" id="gateway" name="gateway"><br>
        </div>
        <input type="submit" value="Submit">
    </form>
    <script>
        function toggleStaticIP() {
            var checkBox = document.getElementById("use_static_ip");
            var staticIPConfig = document.getElementById("static_ip_config");
            if (checkBox.checked == true){
                staticIPConfig.style.display = "block";
            } else {
                staticIPConfig.style.display = "none";
            }
        }
    </script>
    """
    return 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n' + html_template.format(content=content)

# Manejar configuración de red Wi-Fi
def manejar_post_config(solicitud):
    print(f"Solicitud de configuración recibida: {solicitud}")
    ssid = parsear_datos_formulario(solicitud, 'ssid')
    password = parsear_datos_formulario(solicitud, 'password')
    use_static_ip = 'use_static_ip' in solicitud
    ip = parsear_datos_formulario(solicitud, 'ip') if use_static_ip else None
    netmask = parsear_datos_formulario(solicitud, 'netmask') if use_static_ip else None
    gateway = parsear_datos_formulario(solicitud, 'gateway') if use_static_ip else None
    print(f"SSID obtenido: {ssid}")
    print(f"Password obtenido: {password}")
    print(f"IP obtenida: {ip}")
    wifi_manager.guardar_credenciales_wifi(ssid, password, ip, netmask, gateway)
    machine.reset()  # Reiniciar el ESP32 para aplicar la nueva configuración
    return 'HTTP/1.1 200 OK\r\n\r\nConfiguración guardada. Reiniciando...'

# Servir página de reinicio
def servir_pagina_reboot():
    content = "<h2>Reiniciar</h2><form action='/reboot' method='post'><input type='submit' value='Reiniciar'></form>"
    return 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n' + html_template.format(content=content)

# Manejar reinicio del ESP32
def manejar_post_reboot():
    machine.reset()
    return 'HTTP/1.1 200 OK\r\n\r\nReiniciando...'

# Servir página de gestión de archivos
def servir_pagina_gestion_archivos():
    archivos = os.listdir()
    archivo_list = ''.join([f'<li>{archivo} <button onclick="startScript(\'{archivo}\')">Iniciar</button> <button onclick="deleteFile(\'{archivo}\')">Eliminar</button></li>' for archivo in archivos if archivo.endswith('.py')])
    content = f"""
    <h2>Gestión de Archivos</h2>
    <form id="uploadForm" enctype="multipart/form-data">
        <input type="file" id="file" name="file"><br>
        <button type="button" onclick="uploadFile()">Subir</button>
    </form>
    <ul>{archivo_list}</ul>
    <div id="output"></div>
    <script>
        function uploadFile() {{
            var file = document.getElementById('file').files[0];
            var formData = new FormData();
            formData.append('file', file);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/upload', true);
            xhr.onload = function() {{
                if (xhr.status == 200) {{
                    document.getElementById('output').innerText = 'Archivo subido exitosamente.';
                    location.reload();
                }} else {{
                    document.getElementById('output').innerText = 'Error al subir archivo.';
                }}
            }};
            xhr.send(formData);
        }}

        function startScript(filename) {{
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/start', true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.onload = function() {{
                if (xhr.status == 200) {{
                    document.getElementById('output').innerText = 'Script iniciado exitosamente.';
                }} else {{
                    document.getElementById('output').innerText = 'Error al iniciar script.';
                }}
            }};
            xhr.send(JSON.stringify({{ filename: filename }}));
        }}

        function deleteFile(filename) {{
            var xhr = new XMLHttpRequest();
            xhr.open('DELETE', '/file/' + filename, true);
            xhr.onload = function() {{
                if (xhr.status == 200) {{
                    document.getElementById('output').innerText = 'Archivo eliminado exitosamente.';
                    location.reload();
                }} else {{
                    document.getElementById('output').innerText = 'Error al eliminar archivo.';
                }}
            }};
            xhr.send();
        }}
    </script>
    """
    return 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n' + html_template.format(content=content)

# Manejar inicio de script
def manejar_post_start(solicitud):
    try:
        data = json.loads(solicitud.split('\r\n\r\n')[1])
        filename = data.get('filename')
        print(f"Iniciando script: {filename}")
        import __main__
        __main__.script = filename
        _thread.start_new_thread(lambda: exec(open(filename).read(), globals()), ())
        return 'HTTP/1.1 200 OK\r\n\r\nScript iniciado.'
    except Exception as e:
        print(f"Error al iniciar el script: {e}")
        return 'HTTP/1.1 500 Internal Server Error\r\n\r\nError al iniciar el script.'

# Manejar detención de script
def manejar_post_stop():
    try:
        import __main__
        __main__.script = None
        machine.reset()  # Reiniciar para detener cualquier script en ejecución
        return 'HTTP/1.1 200 OK\r\n\r\nScript detenido.'
    except Exception as e:
        print(f"Error al detener el script: {e}")
        return 'HTTP/1.1 500 Internal Server Error\r\n\r\nError al detener el script.'

# Manejar subida de archivos
def manejar_post_upload(solicitud):
    try:
        boundary = solicitud.split('\r\n')[1]
        file_data = solicitud.split(boundary)[1]
        file_header = file_data.split('\r\n')[1]
        file_content = file_data.split('\r\n\r\n')[1].rsplit('\r\n--', 1)[0]
        filename = file_header.split('filename=')[1].strip('"')
        with open(filename, 'wb') as f:
            f.write(file_content.encode('latin1'))  # Asegurarse de manejar los bytes correctamente
        return 'HTTP/1.1 200 OK\r\n\r\nArchivo subido exitosamente.'
    except Exception as e:
        print(f"Error al subir archivo: {e}")
        return 'HTTP/1.1 500 Internal Server Error\r\n\r\nError al subir archivo.'

# Manejar eliminación de archivos
def manejar_delete_file(solicitud, path):
    nombre_archivo = path.split('/file/')[1]
    try:
        os.remove(f'/{nombre_archivo}')
        return 'HTTP/1.1 200 OK\r\n\r\nArchivo eliminado exitosamente.'
    except Exception as e:
        print(f"Error al eliminar archivo: {e}")
        return 'HTTP/1.1 500 Internal Server Error\r\n\r\nError al eliminar el archivo.'

# Servir página de logs
def servir_pagina_logs():
    try:
        with open('/logs/log.txt', 'r') as f:
            logs = f.read()
    except OSError:
        logs = 'No se encontraron logs.'
    content = f"<h2>Logs</h2><pre>{logs}</pre>"
    return 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n' + html_template.format(content=content)

# Parsear datos del formulario
def parsear_datos_formulario(solicitud, nombre_campo):
    try:
        body = solicitud.split('\r\n\r\n')[1]
        params = dict(param.split('=') for param in body.split('&'))
        return params.get(nombre_campo, '')
    except (IndexError, KeyError):
        print(f"Error al parsear el campo {nombre_campo}")
        return ''

# Manejar WebSocket
def manejar_websocket(cliente):
    global ws_clients
    ws_clients.append(cliente)
    try:
        while True:
            msg = cliente.recv(1024)
            if not msg:
                break
            send_console_output(msg)
    finally:
        ws_clients.remove(cliente)

# Enviar mensaje a todos los clientes WebSocket
def send_console_output(message):
    global ws_clients
    for client in ws_clients:
        try:
            client.send(message)
        except Exception as e:
            print('Error enviando mensaje a WebSocket:', e)

# Servidor HTTP y WebSocket en el mismo puerto
def iniciar():
    wifi_manager.cargar_credenciales_wifi()
    if wifi_manager.SSID and wifi_manager.PASSWORD:
        wifi_manager.conectar_wifi()
    else:
        wifi_manager.iniciar_ap()
    
    iniciar_servidor()

if __name__ == '__main__':
    iniciar()



--- Contenido de websocket_helper.py ---

import usocket as socket

def websocket_server(addr, handler):
    s = socket.socket()
    s.bind(addr)
    s.listen(5)
    while True:
        cl, addr = s.accept()
        handler(cl, addr)

def websocket_handler(client, addr):
    try:
        while True:
            msg = client.recv(1024)
            if not msg:
                break
            client.send(msg)  # Echo message back to client (simple handler)
    except Exception as e:
        print("WebSocket error:", e)
    finally:
        client.close()



--- Contenido de wifi_manager.py ---

import machine
import utime
import network
import urequests
import json
from umqtt.robust import MQTTClient

class WiFiManager:
    SSID = None
    PASSWORD = None
    IP = None
    NETMASK = None
    GATEWAY = None
    WIFI_CONFIG_FILE = "/wifi_config.json"  # Archivo para almacenar las credenciales Wi-Fi

    def __init__(self):
        self.sta_if = network.WLAN(network.STA_IF)
        self.sta_if.active(True)
        self.ap_if = network.WLAN(network.AP_IF)
        self.ap_if.active(False)
        self.cargar_credenciales_wifi()

    def conectar_wifi(self):
        if self.SSID and self.PASSWORD:
            print(f"Conectando a la red Wi-Fi {self.SSID}...")
            if self.IP and self.NETMASK and self.GATEWAY:
                print(f"Configurando IP estática: IP={self.IP}, NETMASK={self.NETMASK}, GATEWAY={self.GATEWAY}")
                self.sta_if.ifconfig((self.IP, self.NETMASK, self.GATEWAY, self.GATEWAY))
            self.sta_if.connect(self.SSID, self.PASSWORD)
            for _ in range(10):
                if self.sta_if.isconnected():
                    print("Conectado a Wi-Fi")
                    ip_address = self.obtener_direccion_ip()
                    print(f"Dirección IP: {ip_address}")
                    self.publicar_ip(ip_address)
                    break
                utime.sleep(1)
        else:
            print("No hay credenciales WiFi disponibles.")

    def cargar_credenciales_wifi(self):
        try:
            with open(self.WIFI_CONFIG_FILE, "r") as f:
                config = json.load(f)
                self.SSID = config.get("ssid")
                self.PASSWORD = config.get("password")
                self.IP = config.get("ip")
                self.NETMASK = config.get("netmask")
                self.GATEWAY = config.get("gateway")
                print(f"Credenciales WiFi cargadas: SSID={self.SSID}, PASSWORD={self.PASSWORD}, IP={self.IP}, NETMASK={self.NETMASK}, GATEWAY={self.GATEWAY}")
        except OSError:
            print("No se encontraron credenciales WiFi guardadas.")

    def guardar_credenciales_wifi(self, ssid, password, ip=None, netmask=None, gateway=None):
        print(f"Guardando credenciales WiFi: SSID={ssid}, PASSWORD={password}, IP={ip}, NETMASK={netmask}, GATEWAY={gateway}")
        self.SSID = ssid
        self.PASSWORD = password
        self.IP = ip
        self.NETMASK = netmask
        self.GATEWAY = gateway
        try:
            with open(self.WIFI_CONFIG_FILE, "w") as f:
                json.dump({"ssid": ssid, "password": password, "ip": ip, "netmask": netmask, "gateway": gateway}, f)
            print(f"Credenciales WiFi guardadas: SSID={ssid}, PASSWORD={password}, IP={ip}, NETMASK={netmask}, GATEWAY={gateway}")
        except Exception as e:
            print(f"Error al guardar credenciales WiFi: {e}")

    def asegurar_conexion_wifi(self):
        retry_count = 0
        while not self.sta_if.isconnected() and retry_count < 5:
            print("Intentando conectar WiFi...")
            self.conectar_wifi()
            retry_count += 1
            utime.sleep(5)
        if not self.sta_if.isconnected():
            print("No se pudo conectar a WiFi después de varios intentos. Reiniciando...")
            machine.reset()

    def obtener_hora_actual(self):
        self.asegurar_conexion_wifi()
        try:
            response = urequests.get("http://worldtimeapi.org/api/timezone/America/Lima")
            data = response.json()
            response.close()
            return data["datetime"]
        except Exception as e:
            print("Error al obtener la fecha y hora:", e)
            return None

    def iniciar_ap(self):
        self.ap_if.active(True)
        # Configurar IP estática
        ip = '192.168.168.192'
        netmask = '255.255.255.0'
        gateway = '192.168.168.192'
        self.ap_if.ifconfig((ip, netmask, gateway, gateway))
        self.ap_if.config(essid='HDD-Monitor', password='1234556')
        print('Configuración del Access Point:', self.ap_if.ifconfig())
        return self.ap_if

    def iniciar(self):
        self.cargar_credenciales_wifi()
        if self.SSID and self.PASSWORD:
            self.conectar_wifi()
        else:
            self.iniciar_ap()

    def obtener_direccion_ip(self):
        return self.sta_if.ifconfig()[0]

    def publicar_ip(self, ip):
        try:
            mqtt_client = MQTTClient("ESP32-PQ1", "node02.myqtthub.com", port=8883, user="ESP32-1", password="esp32", ssl=True)
            mqtt_client.connect()
            message = {"date_time": self.obtener_hora_actual(), "name": "ESP32 IP", "status": ip}
            mqtt_client.publish("EMPRESA_TEST/ESP32-PQ1/eventos", json.dumps(message))
            mqtt_client.disconnect()
            print(f"IP publicada al broker MQTT: {ip}")
        except Exception as e:
            print(f"Error al publicar IP al broker MQTT: {e}")


